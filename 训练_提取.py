import os

import cv2
import numpy as np
import torch
from PIL import Image
from torch.utils.data import Dataset, DataLoader

from 神经网络.连接文本提取网络类 import 连接文本提取网络


class 数据处理(Dataset):
    def __init__(self, 图片目录, 标签目录):
        self.图片目录 = 图片目录
        self.标签目录 = 标签目录
        self.图片名列表 = os.listdir(图片目录)

    def __len__(self):
        return len(self.图片名列表)

    def __getitem__(self, 索引):
        图片名 = self.图片名列表[索引]
        图片 = self.读取图片(self.图片目录 + 图片名)
        高, 宽, 通道数 = 图片.shape

        标签文件路径 = os.path.join(self.标签目录, 图片名.split('.')[0] + '.txt')
        标注的大方框列表 = self.读取文件(标签文件路径)
        标注内的小方框矩阵 = self.生成标注内的小方框(标注的大方框列表)
        # print(小方框矩阵.shape)
        # self.画出方框(图片, 注内的小方框矩阵)

        [标签矩阵, 偏移量], 满图的小方框矩阵 = self.生成标签((高, 宽), 标注内的小方框矩阵)
        # self.画出方框(图片, 满图的小方框矩阵)

        图片均值 = [123.68, 116.779, 103.939]  # 固定的，从别人那获取的固定值，根据一个较为全面的很多很多图片统计得出的结果
        减去均值后的图片 = 图片 - 图片均值
        偏移量 = np.hstack([标签矩阵.reshape(标签矩阵.shape[0], 1), 偏移量])
        标签矩阵 = np.expand_dims(标签矩阵, axis=0)

        减去均值后的图片 = torch.from_numpy(减去均值后的图片.transpose([2, 0, 1])).float()
        标签矩阵 = torch.from_numpy(标签矩阵).float()
        偏移量 = torch.from_numpy(偏移量).float()

        return 减去均值后的图片, 标签矩阵, 偏移量

    def 读取图片(self, 图片路径):
        图片 = Image.open(图片路径)
        图片 = cv2.cvtColor(np.asarray(图片), cv2.COLOR_RGB2BGR)
        return 图片

    def 读取文件(self, 文件路径):
        方框列表 = list()
        with open(文件路径, 'r', encoding='utf8') as 文本:
            for 一行 in 文本.readlines():
                一行 = 一行.split('\n')[0]
                一行 = 一行.split(',')
                属性坐标 = list(map(int, 一行[:4]))
                方框列表.append(属性坐标)
            文本.close()
        return 方框列表

    def 生成标注内的小方框(self, 大方框列表):
        """
        通过已经标注好的坐标，在坐标所形成的大方框内生成很多小方框
        :param 大方框列表:
        :return:
        """
        小方框列表 = list()
        for 大方框 in 大方框列表:
            # 大方框数值（左，上，右，下）对应图片的位置
            # 宽度16是个固定值
            左1 = 大方框[0]
            for i in range(大方框[0] // 16 + 1, 大方框[2] // 16 + 1):
                # 左2 = 16 * i - 0.5  # 减0.5是为了与上一个相交？？
                左2 = 16 * i
                小方框列表.append((左1, 大方框[1], 左2, 大方框[3]))
                左1 = 左2
            小方框列表.append((左1, 大方框[1], 大方框[2], 大方框[3]))

        return np.array(小方框列表)

    def 生成满图的小方框(self, 行列数):
        高度 = 35  # 35是事先计算好的值
        宽度 = 16

        行数, 列数 = 行列数
        方框列表 = []
        for 行 in range(行数):
            for 列 in range(列数):
                方框列表.append([宽度 * 列, 高度 * 行, 宽度 * (列 + 1), 高度 * (行 + 1)])
        return np.array(方框列表).reshape((-1, 4))

    def 生成标签(self, 图片尺寸, 标注内的小方框矩阵):
        图片高, 图片宽 = 图片尺寸
        满图的小方框矩阵 = self.生成满图的小方框((int(图片高 / 16), int(图片宽 / 16)))
        重叠部分的交并比矩阵 = self.计算重叠的小方框(满图的小方框矩阵, 标注内的小方框矩阵)

        标签矩阵 = np.empty(满图的小方框矩阵.shape[0])
        标签矩阵.fill(-1)
        # 这里可能固定只有60列，所以有60个描述在哪一行的值，相当于找到最大值的行号
        每一列最大值的行索引 = 重叠部分的交并比矩阵.argmax(axis=0)
        # 这里可能固定只有8040行，所以有8040个描述在哪一列的值，相当于找到最大值的列号
        每一行最大值的列索引 = 重叠部分的交并比矩阵.argmax(axis=1)
        每一行的最大值 = 重叠部分的交并比矩阵[range(重叠部分的交并比矩阵.shape[0]), 每一行最大值的列索引]

        # 好像不存在大于0.7的值。。。。。。，可能需要更改
        # 开始制作标签
        标签矩阵[每一行的最大值 > 0.7] = 1
        标签矩阵[每一行的最大值 < 0.3] = 0
        标签矩阵[每一列最大值的行索引] = 1

        越界的小方框索引 = np.where(
            (满图的小方框矩阵[:, 0] < 0) |
            (满图的小方框矩阵[:, 1] < 0) |
            (满图的小方框矩阵[:, 2] >= 图片宽) |
            (满图的小方框矩阵[:, 3] >= 图片高)
        )[0]
        标签矩阵[越界的小方框索引] = -1

        # 积极的小方框索引 = np.where(标签矩阵 == 1)[0]
        偏移量 = self.微调小方框的边界(满图的小方框矩阵, 标注内的小方框矩阵[每一行最大值的列索引, :])
        return [标签矩阵, 偏移量], 满图的小方框矩阵

    def 微调小方框的边界(self, 满图的小方框矩阵, 标注好的小方框矩阵):
        """
        y：代表各小方框中心坐标的纵坐标的数值
        通过计算两个参数各小方框中心坐标的y值，然后返回两个参数纵坐标y的距离与高之间的比率和满图的小方框的高
        这里为了能够更简单的理解所以变量名很长
        :param 满图的小方框矩阵:
        :param 标注好的小方框矩阵: 大小和满图的小方框矩阵一致，但每一行都是存着标注好的小方框
        :return: 返回两个参数纵坐标y的距离与高之间的比率和满图的小方框的高
        """
        标注好的小方框中心坐标的纵坐标y的矩阵 = (标注好的小方框矩阵[:, 3] + 标注好的小方框矩阵[:, 1]) * 0.5
        满图的小方框中心坐标的纵坐标y的矩阵 = (满图的小方框矩阵[:, 3] + 满图的小方框矩阵[:, 1]) * 0.5
        标注好的小方框高度的矩阵 = 标注好的小方框矩阵[:, 3] - 标注好的小方框矩阵[:, 1] + 1.0
        满图的小方框高度的矩阵 = 满图的小方框矩阵[:, 3] - 满图的小方框矩阵[:, 1] + 1.0

        两者纵坐标距离与其中的满图的小方框的高之间比率的矩阵 = (标注好的小方框中心坐标的纵坐标y的矩阵 - 满图的小方框中心坐标的纵坐标y的矩阵) / 满图的小方框高度的矩阵
        # 由于当前高度只有一个值35，所以比率始终是1，加入对数后结果为零......
        两者高之间比率对数的矩阵 = np.log(标注好的小方框高度的矩阵 / 满图的小方框高度的矩阵)
        return np.vstack((两者纵坐标距离与其中的满图的小方框的高之间比率的矩阵, 两者高之间比率对数的矩阵)).transpose()

    def 计算重叠的小方框(self, 小方框矩阵1, 小方框矩阵2):
        小方框的面积矩阵1 = (小方框矩阵1[:, 0] - 小方框矩阵1[:, 2]) * (小方框矩阵1[:, 1] - 小方框矩阵1[:, 3])
        小方框的面积矩阵2 = (小方框矩阵2[:, 0] - 小方框矩阵2[:, 2]) * (小方框矩阵2[:, 1] - 小方框矩阵2[:, 3])
        重叠部分的交并比矩阵 = np.zeros((小方框矩阵1.shape[0], 小方框矩阵2.shape[0]))

        for 索引, (小方框, 小方框的面积) in enumerate(zip(小方框矩阵1, 小方框的面积矩阵1)):
            # 生成的都是矩阵
            x1 = np.maximum(小方框[0], 小方框矩阵2[:, 0])
            x2 = np.minimum(小方框[2], 小方框矩阵2[:, 2])
            y1 = np.maximum(小方框[1], 小方框矩阵2[:, 1])
            y2 = np.minimum(小方框[3], 小方框矩阵2[:, 3])

            各重叠部分的面积 = np.maximum(x2 - x1, 0) * np.maximum(y2 - y1, 0)
            # 重叠部分的面积与两个小方框面积之和减去一次重叠部分的比例
            交并比矩阵 = 各重叠部分的面积 / (小方框的面积 + 小方框的面积矩阵2[:] - 各重叠部分的面积[:])
            重叠部分的交并比矩阵[索引][:] = 交并比矩阵
        return 重叠部分的交并比矩阵

    def 画出方框(self, 图片, 方框):
        """
        用于可视化显示图片处理效果
        :param 方框:
        :return:
        """
        for i in range(len(方框)):
            点1 = int(方框[i][0]), int(方框[i][1])
            点2 = int(方框[i][2]), int(方框[i][3])
            图片 = cv2.rectangle(图片, 点1, 点2, (100, 200, 100))
        cv2.imshow('fangkuang', 图片)
        cv2.waitKey()
        cv2.destroyAllWindows()


if __name__ == '__main__':
    图片目录 = '图片/训练_提取/'
    标签目录 = '标签/坐标/'
    训练用数据 = 数据处理(图片目录, 标签目录)
    # 训练用数据.__getitem__(0)
    训练用数据加载器 = DataLoader(训练用数据, batch_size=1, shuffle=True)

    设备 = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
    模型 = 连接文本提取网络()
    模型.to(设备)

    for 轮回 in range(100):
        模型.train()
        for 索引, (图片, 标签矩阵, 偏移量) in enumerate(训练用数据加载器):
            输出的标签, 输出的偏移量 = 模型(图片)
    pass

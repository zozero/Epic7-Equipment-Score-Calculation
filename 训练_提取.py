import os

import cv2
import numpy as np
from PIL import Image
from torch.utils.data import Dataset


class 数据处理(Dataset):
    def __init__(self, 图片目录, 标签目录):
        self.图片目录 = 图片目录
        self.标签目录 = 标签目录
        self.图片名列表 = os.listdir(图片目录)

    def __len__(self):
        return len(self.图片名列表)

    def __getitem__(self, 索引):
        图片名 = self.图片名列表[索引]
        图片 = self.读取图片(self.图片目录 + 图片名)
        高, 宽, 通道数 = 图片.shape

        标签文件路径 = os.path.join(self.标签目录, 图片名.split('.')[0] + '.txt')
        标注的大方框列表 = self.读取文件(标签文件路径)
        标注内的小方框矩阵 = self.生成标注内的小方框(标注的大方框列表)
        # print(小方框矩阵.shape)
        # self.画出方框(图片, 注内的小方框矩阵)
        满图的小方框 = self.生成标签((高, 宽), 标注内的小方框矩阵)
        self.画出方框(图片, 满图的小方框)

    def 读取图片(self, 图片路径):
        图片 = Image.open(图片路径)
        图片 = cv2.cvtColor(np.asarray(图片), cv2.COLOR_RGB2BGR)
        return 图片

    def 读取文件(self, 文件路径):
        方框列表 = list()
        with open(文件路径, 'r', encoding='utf8') as 文本:
            for 一行 in 文本.readlines():
                一行 = 一行.split('\n')[0]
                一行 = 一行.split(',')
                属性坐标 = list(map(int, 一行[:4]))
                方框列表.append(属性坐标)
            文本.close()
        return 方框列表

    def 生成标注内的小方框(self, 大方框列表):
        """
        通过已经标注好的坐标，在坐标所形成的大方框内生成很多小方框
        :param 大方框列表:
        :return:
        """
        小方框列表 = list()
        for 大方框 in 大方框列表:
            # 大方框数值（左，上，右，下）对应图片的位置
            # 宽度16是个固定值
            左1 = 大方框[0]
            for i in range(大方框[0] // 16 + 1, 大方框[2] // 16 + 1):
                # 左2 = 16 * i - 0.5  # 减0.5是为了与上一个相交？？
                左2 = 16 * i
                小方框列表.append((左1, 大方框[1], 左2, 大方框[3]))
                左1 = 左2
            小方框列表.append((左1, 大方框[1], 大方框[2], 大方框[3]))

        return np.array(小方框列表)

    def 生成满图的小方框(self, 行列数):
        高度 = 35  # 35是事先计算好的值
        宽度 = 16

        行数, 列数 = 行列数
        方框列表 = []
        for 行 in range(行数):
            for 列 in range(列数):
                方框列表.append([宽度 * 列, 高度 * 行, 宽度 * (列 + 1), 高度 * (行 + 1)])
        return np.array(方框列表).reshape((-1, 4))

    def 生成标签(self, 图片尺寸, 标注内的小方框矩阵):
        图片高, 图片宽 = 图片尺寸
        满图的小方框矩阵 = self.生成满图的小方框((int(图片高 / 16), int(图片宽 / 16)))
        重叠部分的交并比矩阵 = self.计算重叠的小方框(满图的小方框矩阵, 标注内的小方框矩阵)

        标签矩阵 = np.empty(满图的小方框矩阵.shape[0])
        标签矩阵.fill(-1)
        # 这里可能固定只有60列，所以有60个描述在哪一行的值，相当于找到最大值的行号
        每一列最大值的行索引 = 重叠部分的交并比矩阵.argmax(axis=0)
        # 这里可能固定只有8040行，所以有8040个描述在哪一列的值，相当于找到最大值的列号
        每一行最大值的列索引 = 重叠部分的交并比矩阵.argmax(axis=1)
        每一行的最大值 = 重叠部分的交并比矩阵[range(重叠部分的交并比矩阵.shape[0]), 每一行最大值的列索引]

        # 好像不存在大于0.7的值。。。。。。，可能需要更改
        # 开始制作标签
        标签矩阵[每一行的最大值 > 0.7] = 1
        标签矩阵[每一行的最大值 < 0.3] = 0
        标签矩阵[每一列最大值的行索引] = 1

        越界的小方框索引 = np.where(
            (满图的小方框矩阵[:, 0] < 0) |
            (满图的小方框矩阵[:, 1] < 0) |
            (满图的小方框矩阵[:, 2] >= 图片宽) |
            (满图的小方框矩阵[:, 3] >= 图片高)
        )[0]
        标签矩阵[越界的小方框索引] = -1

        积极的小方框索引 = np.where(标签矩阵 == 1)[0]
        return 满图的小方框矩阵

    def 计算重叠的小方框(self, 小方框矩阵1, 小方框矩阵2):
        小方框的面积矩阵1 = (小方框矩阵1[:, 0] - 小方框矩阵1[:, 2]) * (小方框矩阵1[:, 1] - 小方框矩阵1[:, 3])
        小方框的面积矩阵2 = (小方框矩阵2[:, 0] - 小方框矩阵2[:, 2]) * (小方框矩阵2[:, 1] - 小方框矩阵2[:, 3])
        重叠部分的交并比矩阵 = np.zeros((小方框矩阵1.shape[0], 小方框矩阵2.shape[0]))

        for 索引, (小方框, 小方框的面积) in enumerate(zip(小方框矩阵1, 小方框的面积矩阵1)):
            # 生成的都是矩阵
            x1 = np.maximum(小方框[0], 小方框矩阵2[:, 0])
            x2 = np.minimum(小方框[2], 小方框矩阵2[:, 2])
            y1 = np.maximum(小方框[1], 小方框矩阵2[:, 1])
            y2 = np.minimum(小方框[3], 小方框矩阵2[:, 3])

            各重叠部分的面积 = np.maximum(x2 - x1, 0) * np.maximum(y2 - y1, 0)
            # 重叠部分的面积与两个小方框面积之和减去一次重叠部分的比例
            交并比矩阵 = 各重叠部分的面积 / (小方框的面积 + 小方框的面积矩阵2[:] - 各重叠部分的面积[:])
            重叠部分的交并比矩阵[索引][:] = 交并比矩阵
        return 重叠部分的交并比矩阵

    def 画出方框(self, 图片, 方框):
        """
        用于可视化显示图片处理效果
        :param 方框:
        :return:
        """
        for i in range(len(方框)):
            点1 = int(方框[i][0]), int(方框[i][1])
            点2 = int(方框[i][2]), int(方框[i][3])
            图片 = cv2.rectangle(图片, 点1, 点2, (100, 200, 100))
        cv2.imshow('fangkuang', 图片)
        cv2.waitKey()
        cv2.destroyAllWindows()


if __name__ == '__main__':
    图片目录 = '图片/训练_提取/'
    标签目录 = '标签/坐标/'
    训练用数据 = 数据处理(图片目录, 标签目录)
    训练用数据.__getitem__(0)
    pass
